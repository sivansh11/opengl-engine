#version 450 core

#define FLT_MAX 3.402823466e+38

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;

struct Triangle {
    vec3 v0;
    vec3 v1;
    vec3 v2;
};

struct BvhNode {
    vec3 aabbMin;
    uint leftFirst;
    vec3 aabbMax;
    uint triCount;
};

struct Ray {
    vec3 o;
    vec3 d;
    vec3 rD;
    float t;
};

layout (std430, binding = 0) readonly buffer Triangles {
    Triangle triangles[];
};

layout (std430, binding = 1) readonly buffer TriangleIDs {
    uint triangleIDs[];
};

layout (std430, binding = 2) readonly buffer BvhNodes {
    BvhNode bvhNodes[];
};

layout (std430, binding = 3) buffer ret_val {
    float val[3];
};

Ray newRay(vec3 o, vec3 d);
vec3 rayAt(Ray ray);
bool bvhNodeIsLeaf(BvhNode node);
void intersectTriangle(inout Ray ray, Triangle triangle);
float intersectBoundingBox(inout Ray ray, vec3 min, vec3 max);
void intersect(inout Ray ray, uint nodeID);

void main() {
    
    Ray ray = newRay(vec3(0, 0, 0), vec3(0, 0, 1));

    intersect(ray, 0);

    vec3 at = rayAt(ray);

    val[0] = at.x;
    val[1] = at.y;
    val[2] = at.z;


}

Ray newRay(vec3 o, vec3 d) {
    Ray r;
    r.o = o;
    r.d = d;
    r.rD = vec3(1 / d.x, 1 / d.y, 1 / d.z);
    r.t = FLT_MAX;
    return r;
}

vec3 rayAt(Ray ray) {
    return ray.o + (ray.d * ray.t);
}

bool bvhNodeIsLeaf(BvhNode node) {
    return node.triCount > 0;
}

void intersectTriangle(inout Ray ray, Triangle triangle) {
    vec3 edge1 = triangle.v1 - triangle.v0;
    vec3 edge2 = triangle.v2 - triangle.v0;
    vec3 h = cross(ray.d, edge2);
    float a = dot(edge1, h);
    if (abs(a) < 0.0001f) return;
    float f = 1.0f / a;
    vec3 s = ray.o - triangle.v0;
    float u = f * dot(s, h);
    if (u < 0 || u > 1) return;
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.d, q);
    if (v < 0 || u + v > 1) return;
    float t = f * dot(edge2, q);
    if (t < 0.0001f) return;
    if (ray.t < t) return;  // if the ray contains a better/closer intersection, then leave and dont update anything
    ray.t = t;  // only need to update t
}

float intersectBoundingBox(inout Ray ray, vec3 min_, vec3 max_) {
    float tmin, tmax;
    float tx1 = (min_.x - ray.o.x) * ray.rD.x, tx2 = (max_.x - ray.o.x) * ray.rD.x;
    tmin = min(tx1, tx2); 
    tmax = max(tx1, tx2);
    float ty1 = (min_.y - ray.o.y) * ray.rD.y, ty2 = (max_.y - ray.o.y) * ray.rD.y;
    tmin = max(tmin, min(ty1, ty2)); 
    tmax = min(tmax, max(ty1, ty2));
    float tz1 = (min_.z - ray.o.z) * ray.rD.z, tz2 = (max_.z - ray.o.z) * ray.rD.z;
    tmin = max(tmin, min(tz1, tz2)); 
    tmax = min(tmax, max(tz1, tz2));
    if (tmax >= tmin && tmin < ray.t && tmax > 0) return tmin;
    else return FLT_MAX;
}

void intersect(inout Ray ray, uint nodeID) {
    BvhNode node = bvhNodes[nodeID];
    BvhNode stack[64];
    int stackPtr = 0;
    while (true) {
        if (bvhNodeIsLeaf(node)) {
            for (int i = 0; i < node.triCount; i++) {
                intersectTriangle(ray, triangles[triangleIDs[node.leftFirst + i]]);
            }
            if (stackPtr == 0) {
                break;
            } else {
                stackPtr -= 1;
                node = stack[stackPtr];
            }
            continue;
        }
        BvhNode child1 = bvhNodes[node.leftFirst];
        BvhNode child2 = bvhNodes[node.leftFirst + 1];

        float dist1 = intersectBoundingBox(ray, child1.aabbMin, child1.aabbMax);
        float dist2 = intersectBoundingBox(ray, child2.aabbMin, child2.aabbMax);

        if (dist1 > dist2) {
            float temp = dist1;
            dist1 = dist2;
            dist2 = temp;

            BvhNode tempNode = child1;
            child1 = child2;
            child2 = tempNode;
        }

        if (dist1 == FLT_MAX) {
            if (stackPtr == 0) {
                break;
            } else {
                stackPtr -= 1;
                node = stack[stackPtr];
            }
        } else {
            node = child1;
            if (dist2 != FLT_MAX) {
                stack[stackPtr] = child2;
                stackPtr += 1;
            }
        }

    }
    
}